Name: YOUR NAME HERE

| Date   |     Time      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Update |
|:-------|:-------------:|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Sep 11 |  8:00-8:30am  |                                                    I've separated the problem into 2 cases: if hospitals are cheapest, and if highways are cheapest. The 1st case seems easy to solve (just do all hospitals), but the 2nd case needs an algorithm to optimize cost b/w hospitals AND highways. I looked into priority queues and minimum spanning trees, but neither seems like it would really help in an efficient way. After learning about the efficient approach to Moksha Patam, I am thinking about how I could maybe use arrays/maps, or even arraylists to solve this problem efficiently. |
| Sep 11 | 10:00-10:30am | Because of the 2 options for each move (add a highway or a hospital), I started considering a recursive algorithm with 2 paths for each move. But I don't think this would be super efficient. I need to figure out the # of clusters per set of nodes, and then from there, the cost calculation should be pretty simple. Each cluster needs 1 hospital, so get the cost of that, then get the cost of the minimum # of highways. But the biggest challenge of this is: how can I find # of clusters? My instinct is to use a nested for loop and an arraylist of arraylists to track each cluster. |
| Sep 11 | 11:00-11:30am |                                                                                                                                                                                                                                                                                                                                                                                                                                                                       I started coding the various cases that I outlined above and wrote pseudocode for the case where highway cost < hospital cost. |
| Sep 12 |  6:00-6:30am  |                                                                                                                                                                                                                                                     I wrote actual code in place of my pseudocode. It works for the first test, but it underestimates the actual price by a lot for the other tests. I also don't think I'm calculating the # of clusters in a very efficient way, given the nested for loops that I'm having to use, and the arraylist within an arraylist takes up a lot of space. |
| Sep 13 |  1:50-2:20pm  |                                                                                                                                                                                                                                                                                                              After learning about it in class, I implemented the union-find algorithm to calculate the # of clusters in the most efficient way possible. My answer is not correct each time, but it is within five, so I am going to check over my code to see if I am indexing everything properly. |
| Sep 18 |  1:20-1:50pm  |                                                                                                                                                                                                                                                           Before attempting to fix my indexing issue, I tried implementing path compression & weight balancing to improve efficiency. However, my code is now stuck in an infinite loop. I have added print statements to identify where the code could be failing, but they are printing inconsistently, so I haven't made much debugging progress. |
| Sep 19 | 10:00-10:30am |                                                                                                                                                                                                                                                                                                                                                                                                           Mr. Blick helped me fix my infinite loop (for path compression, I was using a while loop that would always be true). I was also able to adjust my indexing issue & pass all of the checks. |
| Sep 18 |   5:30-6:00   |                                                                                                                                                                                                                                                                                                                                                                                                                                                            I went back through my code to improve documentation, make a couple sections more concise, and add helper methods to improve abstraction. |


To add a new row to the table, click into a cell and then hit shift-enter.